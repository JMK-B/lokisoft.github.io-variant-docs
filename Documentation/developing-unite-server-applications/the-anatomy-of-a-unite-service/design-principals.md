## Design Principals

Unite Server apps are built with an ‘Intent first, implementation second’ based method of building apps. An example of this would be a (very simplified) business requirement that allows a customer to send us information and store it for later use and then retrieve it somehow. The business hasn’t specified how we get the data in or where we store it. This is basically the intent of our solution: listen for data and then push it to a repository. How this is implemented will be mandated by solution architects. This separation of intent & implementation allows for a common set of intents to be extended by a pluggable architecture on almost infinite implementations.

In UniteServer there are 2 specific ‘intent’ containers connectors and pipes and, depending on the intent type, the same implementation may be applied to both. A few examples of theses intents can be seen below. However before we discuss each we need to look at a Unite Message. Whenever a connector is triggered, be that a timer or an API call etc , a Unite Message is created. This unite message then is passed into each pipeline or scoped pipeline where the message flow allows.

Another benefit of this is reuse and code specialisation. Connectors, pipes and strategies can be specialised and shared across multiple projects using extension packages. An example of this would be getting files from azure storage. Rather than creating this pipe and add the same settings each time we need this class we an create a specialised pipe that already contains say the account name, account key and directory. When created you name it accordingly and use that specialisation instead. Specialisations can also be grouped into multiple pipes and scoped pipes for building robust pipes which abstract multiple pipes in a single pipe. This is gone into much more detail later on in this document.
